// Generated by CoffeeScript 1.4.0
(function() {

  module.exports = {
    magic: 'PHP',
    chunks: {},
    hash: (function(md5) {
      return function(x) {
        return md5(x).substr(0, 8);
      };
    })(require('MD5')),
    strip: function(x) {
      var c, chunks, h, in_php, php, php_introns, stripped, _i, _len,
        _this = this;
      if (false) {
        return x.replace(/<[?]([^?]+|[?]+[^?>])*[?]>/g, function(x) {
          var h;
          h = _this.hash(x);
          _this.chunks[h] = x;
          return _this.magic + h;
        });
      } else {
        chunks = x.split(/(<[?]|[?]>)/);
        stripped = [];
        php = [];
        in_php = 0;
        php_introns = 0;
        for (_i = 0, _len = chunks.length; _i < _len; _i++) {
          c = chunks[_i];
          if (c === "<?") {
            php_introns++;
            in_php++;
          }
          if (in_php > 0) {
            php.push(c);
          } else if (in_php === 0) {
            stripped.push(c);
          } else {
            throw "A PHP terminator code was found in excess";
          }
          if (c === "?>") {
            in_php--;
            if (in_php === 0) {
              x = php.join('');
              php = [];
              h = this.hash(x);
              this.chunks[h] = x;
              stripped.push(this.magic + h);
            }
          }
        }
        if (in_php === 1 && php_introns === 1) {
          in_php = 0;
          x = php.join('');
          php = [];
          h = this.hash(x);
          this.chunks[h] = x;
          stripped.push(this.magic + h);
        }
        if (in_php !== 0) {
          throw "PHP code was not terminated";
        }
        return stripped.join('');
      }
    },
    apply: function(x) {
      return x.apply(this);
    },
    memberp: function(x) {
      return this.chunks[x] != null;
    },
    dress: function(x) {
      var _this = this;
      x = x.replace(/php[0-9a-z]{8}=""/g, function(x) {
        var _ref;
        return (_ref = _this.chunks[x.substring(3, 11)]) != null ? _ref : "FAIL" + x;
      });
      x = x.replace(/PHP[0-9a-z]{8}/ig, function(x) {
        var _ref;
        return (_ref = _this.chunks[x.substring(3, 11)]) != null ? _ref : "FAIL" + x;
      });
      return x;
    },
    idp: function(x) {
      return /^PHP[0-9a-z]{8}/i.test(x) && this.memberp(x.substring(3, 11));
    },
    idp_strict: function(x) {
      return /^PHP[0-9a-z]{8}$/i.test(x) && this.memberp(x.substring(3, 11));
    },
    id2key: function(x) {
      if (/PHP[0-9a-z]{8}/i.test(x)) {
        return x.substring(3, 11);
      }
    },
    split: function(x) {
      var l, p, y, _i, _len, _ref;
      l = [];
      p = "";
      _ref = x.split(/(PHP[0-9a-z]{8})/i);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        y = _ref[_i];
        if (this.memberp(y)) {
          p = p + y;
          throw p;
        }
        if (p.length) {
          l.push(p);
        }
        p = y;
      }
      if (p.length) {
        l.push(p);
      }
      return l;
    },
    hasAnyChunk: function(x) {
      var y, _i, _len, _ref;
      _ref = x.split(/PHP([0-9a-z]{8})/i);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        y = _ref[_i];
        if (this.memberp(y)) {
          return true;
        }
      }
      return false;
    },
    idToChunk: function(x) {
      var y;
      if (this.idp_strict(x)) {
        if (y = this.id2key(x)) {
          return this.chunks[y];
        }
      }
    }
  };

}).call(this);
